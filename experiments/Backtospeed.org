* Figuring out where I left off
:PROPERTIES:
:header_args: :dir (magit-toplevel) :results silent
:END:

This works pretty well. Uses pre-desugared rules. If I remember correctly, there was some problem with the desugaring.

#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --rules vec/good.json --pre-desugared \
      --split-phase auto
      # --rules vec/test3.json \
#+end_src

Cost: 57.115

Let's try with vector width 4. I assume that it won't work.
#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 4 \
      --rules vec/good.json --pre-desugared \
      --split-phase auto
      # --rules vec/test3.json \
#+end_src

Cost: 370.35900000000004

Yep, that didn't work.

Let's try some desugaring. Let's just use the default vector width of 2.
#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --rules vec/test4.json \
      --split-phase auto
#+end_src

Cost: 556.059

So this doesn't seem to be working...I wonder why.

Let's check to see if the rules are being expanded properly.
#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --rules vec/test4.json \
      --split-phase auto \
      --dry-run --dump-rules
#+end_src

The rules seem to be expanded properly. Let's make sure that the correct rules are indeed being applied? Time to actually read some code.

Nothing obviously wrong. I think this is where I was last time. I have to actually dig through the difference in the rules? The problem is that there are an ungodly number of rules to look through.

Let me dump the rules from a pre-desugared case and see what it looks like.
#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --rules vec/good.json --pre-desugared \
      --split-phase auto \
      --dry-run --dump-rules
#+end_src

I wonder if the numbered variables are breaking things again. That might make a lot of sense.

Just adding some debugging information to make sure that the variables are being picked up correctly.
#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --rules vec/test4.json \
      --split-phase auto \
      --dry-run --dump-rules
#+end_src

Well they seem to be picked up correctly...

What else could be the problem. Let's see if ones of these rules ever applies? I'll restrict the ruleset to just this rule:
#+begin_example
(VecAdd (Vec ?b0 ?b1) (Vec ?a0 ?a1)) <=> (Vec (+ ?a0 ?b0) (+ ?a1 ?b1))
#+end_example

Actually, first let me look at the example. and see if this rule should be able to apply.
#+begin_example
(Concat
  (Vec
    (+
      (+
        (* (Get aq 3) (Get bq 0))
        (+ (* (Get aq 0) (Get bq 3)) (* (Get aq 1) (Get bq 2))))
      (neg (* (Get aq 2) (Get bq 1))))
    (+
      (+
        (* (Get aq 3) (Get bq 1))
        (+ (* (Get aq 1) (Get bq 3)) (* (Get aq 2) (Get bq 0))))
      (neg (* (Get aq 0) (Get bq 2)))))
  (Concat
    (Vec
      (+
        (+
          (* (Get aq 3) (Get bq 2))
          (+ (* (Get aq 2) (Get bq 3)) (* (Get aq 0) (Get bq 1))))
        (neg (* (Get aq 1) (Get bq 0))))
      (+
        (* (Get aq 3) (Get bq 3))
        (+
          (neg (* (Get aq 0) (Get bq 0)))
          (+ (neg (* (Get aq 1) (Get bq 1))) (neg (* (Get aq 2) (Get bq 2)))))))
    (Concat
      (Vec
        (+
          (Get at 0)
          (+
            (Get bt 0)
            (+
              (+
                (*
                  (Get aq 1)
                  (* 2 (+ (* (Get aq 0) (Get bt 1)) (neg (* (Get aq 1) (Get bt 0))))))
                (neg
                  (*
                    (Get aq 2)
                    (* 2 (+ (* (Get aq 2) (Get bt 0)) (neg (* (Get aq 0) (Get bt 2))))))))
              (*
                (Get aq 3)
                (* 2 (+ (* (Get aq 1) (Get bt 2)) (neg (* (Get aq 2) (Get bt 1)))))))))
        (+
          (Get at 1)
          (+
            (Get bt 1)
            (+
              (+
                (*
                  (Get aq 2)
                  (* 2 (+ (* (Get aq 1) (Get bt 2)) (neg (* (Get aq 2) (Get bt 1))))))
                (neg
                  (*
                    (Get aq 0)
                    (* 2 (+ (* (Get aq 0) (Get bt 1)) (neg (* (Get aq 1) (Get bt 0))))))))
              (*
                (Get aq 3)
                (* 2 (+ (* (Get aq 2) (Get bt 0)) (neg (* (Get aq 0) (Get bt 2))))))))))
      (Vec
        (+
          (Get at 2)
          (+
            (Get bt 2)
            (+
              (+
                (*
                  (Get aq 0)
                  (* 2 (+ (* (Get aq 2) (Get bt 0)) (neg (* (Get aq 0) (Get bt 2))))))
                (neg
                  (*
                    (Get aq 1)
                    (* 2 (+ (* (Get aq 1) (Get bt 2)) (neg (* (Get aq 2) (Get bt 1))))))))
              (*
                (Get aq 3)
                (* 2 (+ (* (Get aq 0) (Get bt 1)) (neg (* (Get aq 1) (Get bt 0)))))))))
        0))))
#+end_example

I think that it should be. I made a =single.json= file with just this rule. Let's see what happens when i try to run it.
#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --rules vec/single.json --pre-desugared \
      --split-phase auto
#+end_src

I mean that seems to work. hmm.. Let's try to just run the compilation rules for =test4.json=.

#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --rules vec/test4.json \
      --split-phase auto
#+end_src

So just running the compilation rules has much better performance. It actually seems like it's doing something. This means that somehow the pre-optimization phase is the thing that is destroying the performance. I bet what's happening is that the graph is getting so big that all the other phases are just timing out. Let me look at the log and verify that hypothesis.

And then I will try the same thing but just extracting a single program from the "pre-opt" phase. It might also be that my auto filters for the phases are just not that good.

#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --rules vec/test5.json \
      --split-phase auto --dump-rules
#+end_src

Ok. I was just using cost average. And I had my signs backwards. Fixing that drastically improves performance again.

So it's not working with neg at the moment. Let me make sure that i have some neg rules.

Let's see what happens when i don't have any phase split.

#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --rules vec/test5.json
#+end_src

I run out of memory. I'll have to try this on an AWS machine. I don't feel like setting that up right now. I'll do that later.

But what I will do is try running with handwritten rules and then slowly remove some of the handwritten rules and see what goes wrong.

#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --split-phase auto \
      --rules vec/test4.json --handwritten --dump-rules
#+end_src

Hmm, that gave basically the same results as before. Something is not right. I'll dump the rules again.

Ok, let's try just the handwritten rules. We'll keep the phases just for fun. Nevermind, that didn't work. No phases.

#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --handwritten
#+end_src

Ok that worked. so the problem is in the phase separation? I thought that this worked before.

#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --split-phase auto \
      --handwritten --dump-rules
#+end_src

Ok that works. I changed the filtering to use cost_differential instead of cost average. What about for the =vec/test4.json= ruleset.

#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --split-phase auto \
      --rules vec/test4.json \
      --no-dup-vars --cost-filter 0.0 --timeout 3900 --dump-rules
#+end_src

Ok, that ran out of memory. It didn't actually use that much. But it shouldn't need a crazy amount. I'll tweak the values again.

Ok. so i've done some things that I haven't reported to you yet. Basically, I couldn't get the performance to be the way that I wanted. And so I went back and looked through my previous results, found some old commits, and was able to find something that worked.

However, it used the incorrect filters that I had previously "fixed". Pre-compilation used =cost_average < 10.0=. compilation used =10 < cost_average < 70=. and optimization used =cost_average < 70=. This is exactly backwards from what it "should" be. We should start off with the high-cost rules, go to the transition rules, and then do the lowest cost rules.

The fact that this works I think is pretty accidental. But I'll have to make sure. My theory is that this is accidentally filtering way more rules that I thought that it was. I'm going to start by comparing what the "correct" filtering phase distinctions are vs the "incorrect" filtering.

#+begin_src async-shell :dir (magit-toplevel) :results silent
time cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --rules t2.json --pre-desugared \
      --no-dup-vars --cost-filter 0.0 --split-phase auto
#+end_src

Ok, so what's going on, and what do I need to do. The problem is that the rule filtering
that I thought was working is not working in the way that I expected.

I could work check out =--syntax= is doing on the new rule set. This encodes much closer to what I think should be the correct ruleset, though I should double check that.

There was this experiment that James was thinking about. This 2d dimensional exploration of this filtering. I think I can only do that after I have a more sound filtering technique. (The experiment is running ruler for longer and longer, checking the resulting compiler, and then taking a long run and try filtering out more and more rules)

Let me start with checking the =--syntax= flag.
#+begin_src async-shell :dir (magit-toplevel) :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --split-phase none \
      --rules vec/test4.json
#+end_src

* Long experiments commands

Set the elisp compile command to be sending the code to an EC2 machine.
#+begin_src emacs-lisp :results silent
(set-variable 'sgt/elisp-compile-command
	      '(async-shell-command
		(format "cd ~/Research/diospyros && ./sync.sh %s" (ec2/get-ip "exp1"))))
#+end_src

#+begin_src async-shell :dir (ec2/tramp "exp1" "diospyros") :results silent
cargo run --release --manifest-path src/dios-egraphs/Cargo.toml \
      q-prod-out/spec.rkt \
      --vector-width 2 \
      --split-phase syntax \
      --rules vec/test4.json \
      --new-egraph --timeout 60 \
      --dump-rules vec-test4.rules \
      --node-limit 50000000
#+end_src

* Two directions to make things work

1) Try this second cost function for the phase that does some kind of syntax matching.
2) Get more than one program out of the e-graph. something like the n highest scoring programs.
