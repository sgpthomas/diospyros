#+title: Work Log

* Oct 11

I worked on fixing the validator so that it works with =lt=. The first thing I discovered was that I was constructing the CVEC permutations incorrectly. I was adding all perumations to a single CVEC, something like:

#+begin_example
a = [0, 1, 2, ..]
b = [0, 1, 2, ..]
#+end_example

which ofc was not very useful. I fixed it so that it generates CVECs that look like:

#+begin_example
a = [0, 1, 2, ...]
b = [1, 0, 1, ...]
#+end_example

This ruled out a lot of the obviously wrong rules. However, there were still problems. Rules like:

#+begin_example
a < b => a < b + 1
#+end_example

which is obviously correct but was causing things to crash in the =equality.rs= check. My best guess for this is that the validator doesn't preserve transitivity of equality. Which is obviously a problem. But why wasn't it preserving this?

I decided to integrate z3 to perform the equality checking so that I could check my validator against something that's formally correct.

I spent a while trying to deal with converting the egg lang ast into the z3 one. The problem was that I had to deal with the =Datatype= api in the z3 library. This was a pain to figure out and I was also using an older version of the library than I was reading the documentation for.

Once I fixed that, I discovered that you can't check for satisfiability of formulas of the form =a = b= with z3 directly. This is because z3 is just looking for 1 satisfying assignment. Instead you can check =(not a = b)=. If the formula is unsatisfiable, then you know that =a = b=. The logic is that if there are no satisfying assignments to =(not a = b)=, then the converse must be satisfiable.

With that finally working, I still had some problems. Consider:
#+begin_example
(a * b) < (b * a) => (a * a) < (0 * b)
#+end_example

Neither side of the rewrite rule is ever true. So technically they are equivalent. But my feeling is that we don't want rules like this. It was also causing the same =equality.rs= crash. So I think this was also probably violating the transitivity of equality. Not sure though, maybe worth digging more into.

- TODO: dig more into exactly why rules of the above form are bad.

  Anyways, I solved this by making sure that the antecedant of these kinds of rules are satisfiable before I check if the whole rule is equivalent. This solves that problem.

I haven't implemented converstion from =egg -> z3= for Vec rules yet so I haven't tested the whole thing yet.

- TODO: deal with Vec rules in the validator (either with implementing z3 translation or using the existing technique)
* Oct 12+13

Continued working on the validator. This is written from the next day unfortunately, so I don't remember all the tangents I was following. The basic idea though was that I wanted to extend the validator to work on =Div= rules. Following the scheme in =bigint.rs= in ruler, I needed to add back the idea of assumptions. Along the way I got sidetracked because I felt like my approach for dealing with =Lt= wasn't sound and I wanted to make that work with assumptions.

For some reason this wasn't working (though I'm trying this again today and it worked fine. Damn it I need to write this stuff down and think more clearly about what I'm doing before I waste a day doing random things). Anyways at the end of the day, I concluded that I needed to use z3 =forall= to form the correct statements about =lt=. I think this is true when you don't have an equation. Consider:

#+begin_example
a < b => a < b + 1
#+end_example

This is obviously true, but how do you state this to z3 as a satisfiability question? If you ask, is there a satisfying assignment, you can prove false statements:

#+begin_src emacs-lisp
a < b => a < 0
(a < b => a < 0)/{a <- 1, b <- 0}
1 < 0 => 1 < 0
false => false
true (!!)
#+end_src

So that doesn't work. What if we ask about an assignment for the negation:

#+begin_src emacs-lisp
! (a < b => a < 0)
! (! (a < b) || (a < 0))
(a < b) & ! (a < 0)
(a < b) & ! (a < 0)/{a <- 1, b <- 2}
(1 < 2) & ! (1 < 0)
true & ! false
true & true
true
#+end_src

So that doesn't work either. What does work is using a =forall= like so:

#+begin_src emacs-lisp
(forall (a b) a < b => a < 0)
#+end_src

I don't know how to work it out from here, so I'll just say if you ask z3 this question, it gives you the right answer.

However, this was just a tangent because I don't actually need to ask this kind of question. Arghh!! If you ask

#+begin_src emacs-lisp
a < b != a < 0
(a < b != a < 0)/{a <- 1, b <- 2}
1 < 2 != 1 < 0
true != false
true
#+end_src

Because the inverse is satisfiable, this proves that =a < b -> a < 0= is false.

Next I implemented the z3 verifier for =div=. Went smoothly. Jk it crashed :((
* Oct 14

Homework + parents arrived

* Oct 15

For the sake of running experiments, I want to be able to externally manage various settings that I have up until now been tweaking by directly modifying the code. Things I want to be able to parameterize:

- [X] Seed set of rules
- [X] Starting values
- [X] Which operators I'm using (e.g. =lt, mul, add=)
- [X] Which vector oeprators I'm using

* Oct 18

Starting the week. I guess I'll start with some hacking. I'll work through the todo list above.

Example config:
#+begin_src js :tangle test-config.json
{
    "constants": [
	{
	    "type": "int",
	    "value": 0
	},
	{
	    "type": "int",
	    "value": 1
	},
	{
	    "type": "bool",
	    "value": true
	},
	{
	    "type": "bool", 
	    "value": false
	}
    ],
    "seed_rules": [
	{
	    "lhs": "(+ ?a ?b)",
	    "rhs": "(+ ?b ?a)",
	    "bidirectional": true
	}
    ],
    "binops": ["+", "*", "<"],
    "use_vector": false,
    "vector_binops": ["+", "*"]
    
}
#+end_src
