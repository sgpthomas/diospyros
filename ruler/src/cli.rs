use clap::Clap;
use serde::{Deserialize, Serialize};

use crate::{convert_sexp::ConvertParams, derive::DeriveParams, SynthParams};

/// All parameters for rule synthesis.
#[derive(Debug, Clap, Deserialize, Serialize, Clone)]
#[clap(rename_all = "kebab-case")]
pub struct SynthParamsCli {
    /// Seed for random number generator, used for random cvec value generation
    #[clap(long, default_value = "0")]
    pub seed: u64,
    /// How many random values to add to the cvecs
    #[clap(long, default_value = "0")]
    pub n_samples: usize,
    /// Number of variables to add to the initial egraph
    #[clap(long, default_value = "3")]
    pub variables: usize,
    /// Absolute timeout
    #[clap(long, default_value = "120")]
    pub abs_timeout: usize,
    // /// Dios config
    // #[clap(long)]
    // pub dios_config: Option<String>,

    ///////////////////
    // search params //
    ///////////////////
    /// Number of iterations
    #[clap(long, default_value = "1")]
    pub iters: usize,
    /// 0 is unlimited
    #[clap(long, default_value = "0")]
    pub rules_to_take: usize,
    /// 0 is unlimited
    #[clap(long, default_value = "100000")]
    pub chunk_size: usize,
    #[clap(long, conflicts_with = "rules-to-take")]
    pub minimize: bool,
    /// disallows enumerating terms with constants past this iteration
    #[clap(long, default_value = "999999")]
    pub no_constants_above_iter: usize,
    /// For enabling / disabling conditional rule inference
    #[clap(long)]
    pub no_conditionals: bool,
    #[clap(long)]
    /// For turning off `run_rewrites`
    pub no_run_rewrites: bool,
    #[clap(long)]
    pub linear_cvec_matching: bool,
    /// Output file name
    #[clap(long, default_value = "out.json")]
    pub outfile: String,

    ////////////////
    // eqsat args //
    ////////////////
    /// node limit for all the eqsats
    #[clap(long, default_value = "300000")]
    pub eqsat_node_limit: usize,
    /// iter limit for all the eqsats
    #[clap(long, default_value = "2")]
    pub eqsat_iter_limit: usize,
    /// time limit (seconds) for all the eqsats
    #[clap(long, default_value = "60")]
    pub eqsat_time_limit: u64,
    /// Controls the size of cvecs
    #[clap(long, default_value = "5")]
    pub important_cvec_offsets: u32,

    //////////////////////////
    // domain specific args //
    //////////////////////////
    /// (str only), the number of additional int variables
    #[clap(long, default_value = "1")]
    pub str_int_variables: usize,
    /// Only for bv, makes it do a complete cvec
    #[clap(long, conflicts_with = "important-cvec-offsets")]
    pub complete_cvec: bool,
    /// Only for bool/bv
    #[clap(long)]
    pub no_xor: bool,
    /// Only for bv
    #[clap(long)]
    pub no_shift: bool,

    ///////////////////
    // eqsat soundness params //
    ///////////////////
    // for validation approach
    /// random testing based validation
    #[clap(long, default_value = "0")]
    pub num_fuzz: usize,
    /// SMT based verification (uses Z3 for the current prototype)
    #[clap(long, conflicts_with = "num-fuzz")]
    pub use_smt: bool,
    /// For a final round of run_rewrites to remove redundant rules.
    #[clap(long)]
    pub do_final_run: bool,
}

/// Derivability report.
#[derive(Clap)]
#[clap(rename_all = "kebab-case")]
pub struct DeriveParamsCli {
    in1: String,
    in2: String,
    out: String,
    #[clap(long, default_value = "5")]
    iter_limit: usize,
}

/// Report for rules generated by CVC4.
#[derive(Clap)]
#[clap(rename_all = "kebab-case")]
pub struct ConvertParamsCli {
    cvc_log: String,
    out: String,
}

/// Ruler can be run to synthesize rules, compare two rulesets
/// for derivability, and convert CVC4 rewrites to patterns in Ruler.
#[derive(Clap)]
#[clap(rename_all = "kebab-case")]
pub enum Command {
    Synth(SynthParamsCli),
    Derive(DeriveParamsCli),
    ConvertSexp(ConvertParamsCli),
}

impl Command {
    pub fn cli() -> Self {
        Self::parse()
    }
}

impl Into<SynthParams> for SynthParamsCli {
    fn into(self) -> SynthParams {
        SynthParams {
            seed: self.seed,
            n_samples: self.n_samples,
            variables: self.variables,
            abs_timeout: self.abs_timeout,
            // dios_config: self.dios_config,
            iters: self.iters,
            rules_to_take: self.rules_to_take,
            chunk_size: self.chunk_size,
            minimize: self.minimize,
            no_constants_above_iter: self.no_constants_above_iter,
            no_conditionals: self.no_conditionals,
            no_run_rewrites: self.no_run_rewrites,
            linear_cvec_matching: self.linear_cvec_matching,
            outfile: self.outfile,
            eqsat_node_limit: self.eqsat_node_limit,
            eqsat_iter_limit: self.eqsat_iter_limit,
            eqsat_time_limit: self.eqsat_time_limit,
            important_cvec_offsets: self.important_cvec_offsets,
            str_int_variables: self.str_int_variables,
            complete_cvec: self.complete_cvec,
            no_xor: self.no_xor,
            no_shift: self.no_shift,
            num_fuzz: self.num_fuzz,
            use_smt: self.use_smt,
            do_final_run: self.do_final_run,
        }
    }
}

impl Into<ConvertParams> for ConvertParamsCli {
    fn into(self) -> ConvertParams {
        ConvertParams {
            cvc_log: self.cvc_log,
            out: self.out,
        }
    }
}

impl Into<DeriveParams> for DeriveParamsCli {
    fn into(self) -> DeriveParams {
        DeriveParams {
            in1: self.in1,
            in2: self.in2,
            out: self.out,
            iter_limit: self.iter_limit,
        }
    }
}
